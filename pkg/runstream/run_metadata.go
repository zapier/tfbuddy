package runstream

import (
	"encoding/json"
	"time"

	"github.com/nats-io/nats.go"
)

// ensure type complies with interface
var _ RunMetadata = (*TFRunMetadata)(nil)

type TFRunMetadata struct {
	// RunID is the ID generated by TFC for the run
	RunID string
	// Organization is the TFC organization name
	Organization string
	// Workspace is the TFC workspace name
	Workspace string

	// Source is the trigger source of the TFC run
	// options include:
	// "merge_request" - for runs started via MR push or comment
	// "merge" - for runs started when MR is merged (apply after merge repos) (NOT IMPLEMENTED)
	// "slack" - for runs started via ChatOps (NOT IMPLEMENTED)
	Source string

	// Action is the triggered action (i.e. plan / apply)
	Action string

	// The git Commit SHA for which the run has been triggered
	CommitSHA string

	// MergeRequestProjectNameWithNamespace is the fully qualified Gitlab project name (e.g. /group/subgroup/project)
	MergeRequestProjectNameWithNamespace string

	// MergeRequestIID is the Gitlab Merge Request IID for which the Run has been triggered
	MergeRequestIID int

	// DiscussionID is the MergeRequest discussion thread where status updates should be written (optional)
	DiscussionID string
	// RootNoteID is the top level note of the discussion thread. It will be updated with progress info.
	RootNoteID int64

	VcsProvider string
}

func (r *TFRunMetadata) GetAction() string {
	return r.Action
}
func (r *TFRunMetadata) GetMRInternalID() int {
	return r.MergeRequestIID
}
func (r *TFRunMetadata) GetRootNoteID() int64 {
	return r.RootNoteID
}
func (r *TFRunMetadata) GetMRProjectNameWithNamespace() string {
	return r.MergeRequestProjectNameWithNamespace
}
func (r *TFRunMetadata) GetDiscussionID() string {
	return r.DiscussionID
}
func (r *TFRunMetadata) GetRunID() string {
	return r.RunID
}
func (r *TFRunMetadata) GetWorkspace() string {
	return r.Workspace
}
func (r *TFRunMetadata) GetCommitSHA() string {
	return r.CommitSHA
}
func (r *TFRunMetadata) GetOrganization() string {
	return r.Organization
}
func (r *TFRunMetadata) GetVcsProvider() string {
	return r.VcsProvider
}
func (s *Stream) AddRunMeta(rmd RunMetadata) error {
	b, err := encodeTFRunMetadata(rmd)
	if err != nil {
		return err
	}
	_, err = s.metadataKV.Create(rmd.GetRunID(), b)
	return err
}

func (s *Stream) GetRunMeta(runID string) (RunMetadata, error) {
	entry, err := s.metadataKV.Get(runID)
	if err != nil {
		return nil, err
	}
	return decodeTFRunMetadata(entry.Value())
}

func encodeTFRunMetadata(run RunMetadata) ([]byte, error) {
	return json.Marshal(run)
}

func decodeTFRunMetadata(b []byte) (RunMetadata, error) {
	rmd := &TFRunMetadata{}
	err := json.Unmarshal(b, &rmd)

	return rmd, err
}

func configureTFRunMetadataKVStore(js nats.JetStreamContext) (nats.KeyValue, error) {
	cfg := &nats.KeyValueConfig{
		Bucket:      RunMetadataKvBucket,
		Description: "KV store for Run Metadata",
		TTL:         time.Hour * 720,
		Storage:     nats.FileStorage,
		Replicas:    1,
	}

	for store := range js.KeyValueStores() {
		if store.Bucket() == cfg.Bucket {
			return js.KeyValue(cfg.Bucket)
		}
	}

	return js.CreateKeyValue(cfg)
}
